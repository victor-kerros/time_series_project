# Projet de Séries temporelles linéaires - 2A ENSAE

## Partie I : Données

### Q1 - Présentation de la série

``` {r import packages}
# on utilise "zoo" pour formaliser les séries temporelles
#install.packages("zoo")
require(zoo)
# on utilise "tseries" pour diverses fonctions
#install.packages("tseries")
require(tseries)
# on utilise "fUnitRoots" pour les tests de racine unitaire
#install.packages("fUnitRoots")
library(fUnitRoots)
```

Link : https://www.insee.fr/fr/statistiques/serie/010537876 

``` {r import dataset}
datafile <- "elec_valeurs_mensuelles.csv"
data <- read.csv(datafile, sep=";")
# indices <- ts(data[,"indices"], frequency=12, start=c(1990,1))
```

``` {r create dates}
string_dates <- as.character(data$dates)
# premiere et la derniere date pour définir les indices des dates
# string_dates[1]; string_dates[length(string_dates)]
# on définit les dates de la série
dates <- as.yearmon(seq(from=1990+0/12, to=2022+3/12, by=1/12))
```

``` {r create ts elec and delec with zoo}
# on permute la série sinon elle n'est pas dans le bon sens
elec.source <- zoo(rev(data$indices), order.by=dates)
# on enlève les 6 dernières dates à la série en niveau serie
elec <- elec.source[1:(length(elec.source)-6)]
# delec est la série en différence première
delec.source <- diff(elec.source, 1)
delec <- diff(elec, 1)
```

```{r plot elec.source}
plot(elec.source, type="l", lwd=1, col="blue", main="elec.source", xlab="dates", ylab="values" )
```

``` {r decompose and log}
# on passe au log pour lisser l'hétéroscédasticité
decompose_elec <- decompose(elec)
# plot(decompose_elec)
logelec <- log(elec)
decompose_logelec <- decompose(logelec)
plot(decompose_logelec)
```

```{r plot logelec}
plot(logelec, type="l", lwd=1, col="blue", main="elec.source", xlab="dates", ylab="values" )
```

### Q2 - Stationnarisation de la série

On constate sur le graphique ci-dessus une tendance linéaire positive pour la série tronquée en niveau. Dans la mesure où notre série représente le commerce d'électricité, on s'attend également à de la saisonnalité.

On vérifie d'abord la tendance linéaire en effectuant une régression linéaire des valeurs de la série tronquée sur les dates.

```{r lm}
truncated_dates <- dates[1:(length(elec.source)-6)]
summary(lm(logelec ~ truncated_dates))
```

Cette régression linéaire confirme la présence d'une tendance linéaire positive dans nos données et d'une constante : p_values < 1 %.
On observe désormais la saisonnalité.

``` {r decompose and pacf logelec}
decompose_logelec <- decompose(logelec)
plot(decompose_logelec) ; 
pacf(logelec)
```

``` {r dlogelec}
# dlogelec est la série logelec en différence première
dlogelec.source <- diff(log(elec.source), 1)
dlogelec <- diff(logelec, 1)
plot.ts(dlogelec, type="l", lwd=1, col="red", main="dlogelec", xlab="dates", ylab="values")
```

``` {r desaison logelec}
# logelec_desais <- logelec - decompose_logelec$seasonal
logelec_desais <- logelec - lag(logelec, 12)
plot.ts(logelec_desais, type="l", lwd=1, col="red", main="logelec_desais", xlab="dates", ylab="values")
pacf(logelec_desais)
```

``` {r decompose logelec_desais}
plot(decompose(logelec_desais)) ; pacf(logelec_desais)
```

On cherche à déterminer si la série est stationnaire ou non. Pour cela, on souhaite effectuer un test de racine unitaire ADF dont l'hypothèse H1 est la stationnarité de la série. On effectue le test ADF dans le cas avec constante et tendance.

```{r elec adf test}
# cas avec constante et tendance
adfTest(elec, lag=0, type="ct")
```

```{r logelec adf test}
# cas avec constante et tendance
pp.test(elec)
```

```{r test autocorrélation résidus}
Qtests <- function(series, k, fitdf=0){
  pvals <- apply(matrix(1:k), 1, FUN=function(l){
  pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
  return(c("lag"=l,"pval"=pval))
  })
  return(t(pvals))
}
Qtests(adf@test$lm$residuals,24,length(adf@test$lm$coefficients))
```


```{r plot indices}
plot(cbind(elec, delec))
#plot.ts(indices, type="l", lwd=1, col="blue", xlab="date", ylab="indices")
```

``` {r decompose and acf}
plot(decompose(indices)) ; acf(indices)
```

```{r plot dindices}
dindices <- diff(indices, 1) # différence première
plot.ts(dindices, type="l", lwd=1, col="blue", xlab="date", ylab="dindices")
acf(dindices)
```

### Q2 - Stationnarisation de la série

``` {r log}
logindices <- log(data[,"indices"])
logindices <- ts(logindices, frequency=12, start = c(1990,1))
plot.ts(logindices, type="l", lwd=1, col="red", xlab="date", ylab="logindices")
```

``` {r desais}
df_desais <- decompose(logindices)
plot(df_desais)
```

``` {r plot desais}
logindices_desais <- logindices - df_desais$seasonal
plot.ts(logindices_desais,type="l",lwd=1, col="red", xlab="Time", ylab="Indice")
```

``` {r plot desais}
urdfTest(logindices_desais)
```

```{r acf}
acf(logindices_desais) # trace l’autocorrélogramme total
```

```{r desaison}
desaison <- logindices - lag(logindices, -12) # retire le 12ème retard
par(mfrow = c(1,2)) # dispose les graphiques en 1 colonne et 2 lignes
plot(desaison)
acf(desaison)
```

```{r (p)acf desaison}
acf(desaison) # trace les fonctions d’autocorrélation totale
pacf(desaison) # trace les fonctions d’autocorrélation partielle
```

``` {r plot desais}
urdfTest(logindices_desais)
```

### Q3 - Représentation graphique de la série

``` {r}
# Création de la série différenciée
logindicesdiff1 <- diff(logindices_desais, differences=1)
# Représentation graphique de la série différenciée
plot.ts(logindicesdiff1,type="l",lwd=1, col="red", xlab="Time", ylab="Indice")
```

``` {r}
urdfTest(logindicesdiff1)
```

## Partie II : Modèles ARMA

### Q4 - Choix, estimation et validation du modèle ARMA

``` {r}

```

### Q5 - Modèle ARIMA

``` {r}

```

## Partie 3 : Prévisions

### Q6 - Equations de la région de confiance

``` {r}

```

### Q7 - Hypothèses de la région de confiance

``` {r}

```

### Q8 - Représentation graphique de la région de confiance

``` {r}

```

### Q9 - Question ouverte

``` {r}

```