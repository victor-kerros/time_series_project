# Projet de Séries temporelles linéaires - 2A ENSAE

## Partie I : Données

### Q1 - Présentation de la série

``` {r import packages}
# on utilise "zoo" pour formaliser les séries temporelles
install.packages("zoo")
require(zoo)
# on utilise "tseries" pour diverses fonctions
install.packages("tseries")
require(tseries)
# on utilise "fUnitRoots" pour les tests de racine unitaire
install.packages("fUnitRoots")
library(fUnitRoots)
```

``` {r import dataset}
datafile <- "biere_valeurs_mensuelles.csv"
data <- read.csv(datafile, sep=";")
#indices <- ts(data[,"indices"], frequency=12, start=c(1990,1))
```

``` {r create dates}
string_dates <- as.character(data$dates)
# premiere et la derniere date pour définir les indices des dates
string_dates[1]; string_dates[length(string_dates)]
# on définit les dates de la série
dates <- as.yearmon(seq(from=1990+0/12,to=2022+3/12,by=1/12))
```

``` {r create ts elec and delec with zoo}
elec.source <- zoo(data$indices, order.by=dates)
# on enlève les 6 dernières dates à la série en niveau serie
elec <- elec.source[1:(length(elec.source)-6)]
# delec est la série en différence première
delec.source <- diff(elec.source, 1)
delec <- diff(elec,1)
```

```{r plots elec}
plot(elec.source)
plot(cbind(elec, delec))
```

```{r lm}
summary(lm(indice ~ dates[1:(T-4)]))
```

```{r adf test}
adf <- adfTest(indice, lag=0, type="ct") #test ADF dans le cas avec constante et tendance
adf
```
```{r test autocorrélation résidus}
Qtests <- function(series, k, fitdf=0){
  pvals <- apply(matrix(1:k), 1, FUN=function(l){
  pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
  return(c("lag"=l,"pval"=pval))
  })
  return(t(pvals))
}
Qtests(adf@test$lm$residuals,24,length(adf@test$lm$coefficients))
```


```{r plot indices}
plot.ts(indices, type="l", lwd=1, col="blue", xlab="date", ylab="indices")
```

``` {r decompose and acf}
plot(decompose(indices)) ; acf(indices)
```

```{r plot dindices}
dindices <- diff(indices, 1) # différence première
plot.ts(dindices, type="l", lwd=1, col="blue", xlab="date", ylab="dindices")
acf(dindices)
```

### Q2 - Stationnarisation de la série

``` {r log}
logindices <- log(data[,"indices"])
logindices <- ts(logindices, frequency=12, start = c(1990,1))
plot.ts(logindices, type="l", lwd=1, col="red", xlab="date", ylab="logindices")
```

``` {r desais}
df_desais <- decompose(logindices)
plot(df_desais)
```

``` {r plot desais}
logindices_desais <- logindices - df_desais$seasonal
plot.ts(logindices_desais,type="l",lwd=1, col="red", xlab="Time", ylab="Indice")
```

``` {r plot desais}
urdfTest(logindices_desais)
```

```{r acf}
acf(logindices_desais) # trace l’autocorrélogramme total
```

```{r desaison}
desaison <- logindices - lag(logindices, -12) # retire le 12ème retard
par(mfrow = c(1,2)) # dispose les graphiques en 1 colonne et 2 lignes
plot(desaison)
acf(desaison)
```

```{r (p)acf desaison}
acf(desaison) # trace les fonctions d’autocorrélation totale
pacf(desaison) # trace les fonctions d’autocorrélation partielle
```

``` {r plot desais}
urdfTest(logindices_desais)
```

### Q3 - Représentation graphique de la série

``` {r}
# Création de la série différenciée
logindicesdiff1 <- diff(logindices_desais, differences=1)
# Représentation graphique de la série différenciée
plot.ts(logindicesdiff1,type="l",lwd=1, col="red", xlab="Time", ylab="Indice")
```

``` {r}
urdfTest(logindicesdiff1)
```

## Partie II : Modèles ARMA

### Q4 - Choix, estimation et validation du modèle ARMA

``` {r}

```

### Q5 - Modèle ARIMA

``` {r}

```

## Partie 3 : Prévisions

### Q6 - Equations de la région de confiance

``` {r}

```

### Q7 - Hypothèses de la région de confiance

``` {r}

```

### Q8 - Représentation graphique de la région de confiance

``` {r}

```

### Q9 - Question ouverte

``` {r}

```