# Projet de Séries temporelles linéaires - 2A ENSAE

## Partie I : Données

### Q1 - Présentation de la série

```{r packages}
install.packages("zoo")
require(zoo)
install.packages("tseries")
require(tseries)
install.packages("fUnitRoots")
library(fUnitRoots)
```

``` {r import dataset}
datafile <- "alim_valeurs_mensuelles.csv"
data <- read.csv(datafile, sep=";")
indices <- ts(data[,"indices"], frequency=12, start=c(1990,1))
```

``` {r import dates}
dateschar <- as.character(data$date)
dateschar[1]; dateschar[length(dateschar)] # affiche la premiere et la derniere date
dates <- as.yearmon(seq(from=1990+0/12,to=2022+2/12,by=1/12)) #index des dates pour indice
indice.source <- zoo(data$indice, order.by=dates)
T <- length(indice.source)
indice <- indice.source[1:(T-4)] # serie en niveau a laquelle on retire les 4 dernieres dates
```
```{r plot indices}
dindice.source <- diff(indice.source, 1)
dindice <- diff(indice,1) #serie en difference premiere a partir de la serie privee des 4 dernieres dates
plot(indice.source) #representation graphique de la serie initiale
plot(cbind(indice,dindice)) #representation graphique de la serie initiale privee des 4 dernieres observations et de la serie differenciee associee
```
```{r lm}
summary(lm(indice ~ dates[1:(T-4)]))
```
```{r adf test}
adf <- adfTest(indice, lag=0, type="ct") #test ADF dans le cas avec constante et tendance
adf
```
```{r test autocorrélation résidus}
Qtests <- function(series, k, fitdf=0){
  pvals <- apply(matrix(1:k), 1, FUN=function(l){
  pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
  return(c("lag"=l,"pval"=pval))
  })
  return(t(pvals))
}
Qtests(adf@test$lm$residuals,24,length(adf@test$lm$coefficients))
```


```{r plot indices}
plot.ts(indices, type="l", lwd=1, col="blue", xlab="date", ylab="indices")
```

``` {r decompose and acf}
plot(decompose(indices)) ; acf(indices)
```

```{r plot dindices}
dindices <- diff(indices, 1) # différence première
plot.ts(dindices, type="l", lwd=1, col="blue", xlab="date", ylab="dindices")
acf(dindices)
```

### Q2 - Stationnarisation de la série

``` {r log}
logindices <- log(data[,"indices"])
logindices <- ts(logindices, frequency=12, start = c(1990,1))
plot.ts(logindices, type="l", lwd=1, col="red", xlab="date", ylab="logindices")
```

``` {r desais}
df_desais <- decompose(logindices)
plot(df_desais)
```

``` {r plot desais}
logindices_desais <- logindices - df_desais$seasonal
plot.ts(logindices_desais,type="l",lwd=1, col="red", xlab="Time", ylab="Indice")
```

``` {r plot desais}
urdfTest(logindices_desais)
```

```{r acf}
acf(logindices_desais) # trace l’autocorrélogramme total
```

```{r desaison}
desaison <- logindices - lag(logindices, -12) # retire le 12ème retard
par(mfrow = c(1,2)) # dispose les graphiques en 1 colonne et 2 lignes
plot(desaison)
acf(desaison)
```

```{r (p)acf desaison}
acf(desaison) # trace les fonctions d’autocorrélation totale
pacf(desaison) # trace les fonctions d’autocorrélation partielle
```

``` {r plot desais}
urdfTest(logindices_desais)
```

### Q3 - Représentation graphique de la série

``` {r}
# Création de la série différenciée
logindicesdiff1 <- diff(logindices_desais, differences=1)
# Représentation graphique de la série différenciée
plot.ts(logindicesdiff1,type="l",lwd=1, col="red", xlab="Time", ylab="Indice")
```

``` {r}
urdfTest(logindicesdiff1)
```

## Partie II : Modèles ARMA

### Q4 - Choix, estimation et validation du modèle ARMA

``` {r}

```

### Q5 - Modèle ARIMA

``` {r}

```

## Partie 3 : Prévisions

### Q6 - Equations de la région de confiance

``` {r}

```

### Q7 - Hypothèses de la région de confiance

``` {r}

```

### Q8 - Représentation graphique de la région de confiance

``` {r}

```

### Q9 - Question ouverte

``` {r}

```