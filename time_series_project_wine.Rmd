# Projet de Séries temporelles linéaires - 2A ENSAE

## Partie I : Données

### Q1 - Présentation de la série

``` {r import packages}
# on utilise "zoo" pour formaliser les séries temporelles
#install.packages("zoo")
require(zoo)
# on utilise "tseries" pour diverses fonctions
#install.packages("tseries")
require(tseries)
# on utilise "fUnitRoots" pour les tests de racine unitaire
#install.packages("fUnitRoots")
library(fUnitRoots)
```

Link : https://www.insee.fr/fr/statistiques/serie/010537307

``` {r import dataset}
datafile <- "alim_valeurs_mensuelles.csv"
data <- read.csv(datafile, sep=";")
```

``` {r create dates}
string_dates <- as.character(data$dates)
# premiere et la derniere date pour définir les indices des dates
string_dates[1]; string_dates[length(string_dates)]
# on définit les dates de la série
dates <- as.yearmon(seq(from=1990+0/12, to=2022+1/12, by=1/12))
```

``` {r create ts wine and dwine with zoo}
# on permute la série sinon elle n'est pas dans le bon sens
wine.source <- zoo(rev(data$indices), order.by=dates)
# on enlève les 6 dernières dates à la série en niveau serie
wine <- wine.source[1:(length(wine.source)-6)]
# delec est la série en différence première
dwine.source <- diff(wine.source, 1)
dwine <- diff(wine, 1)
```

```{r plot wine.source}
plot(wine.source, type="l", lwd=1, col="blue", main="wine.source", xlab="dates", ylab="values" )
```

``` {r decompose and log}
# on passe au log pour lisser l'hétéroscédasticité
decompose_wine.source <- decompose(wine.source)
plot(decompose_wine.source)
logwine.source <- log(wine.source)
decompose_logwine.source <- decompose(logwine.source)
plot(decompose_logwine.source)
```

```{r plot logwine.source}
plot(logwine.source, type="l", lwd=1, col="blue", main="logwine.source", xlab="dates", ylab="values")
```

### Q2 - Stationnarisation de la série

On constate sur le graphique ci-dessus une tendance linéaire positive pour la série en niveau.

On vérifie d'abord la tendance linéaire en effectuant une régression linéaire des valeurs de la série tronquée sur les dates.

```{r lm}
truncated_dates <- dates[1:(length(logwine.source)-6)]
logwine <- logwine.source[1:(length(logwine.source)-6)]
summary(lm(logwine ~ truncated_dates))
```

Cette régression linéaire confirme la présence d'une tendance linéaire positive dans nos données et d'une constante : p_values < 1 %.

On cherche à déterminer si la série est stationnaire ou non. Pour cela, on souhaite effectuer un test de racine unitaire ADF dont l'hypothèse H1 est la stationnarité de la série. On effectue le test ADF dans le cas avec constante et tendance.

```{r logwine adf test}
# cas avec constante et tendance
adf_logwine <- adfTest(logwine, lag=0, type="ct")
adf_logwine
#pp.test(wine)
```

D'après le test ADF, la série en niveau est stationnaire. Seulement, pour que le test soit valide, il faut que les résidus de la régression ne soient pas autocorrélés.
On teste donc l’autocorrélation des résidus dans la régression sur une période de deux ans.

``` {r test residuals autocorrelation : cf. TD4}

Qtests <- function(series, k, fitdf=0){
  pvals <- apply(matrix(1:k), 1, FUN=function(l){
  pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
  return(c("lag"=l,"pval"=pval))
  })
  return(t(pvals))
}

Qtests(adf_logwine@test$lm$residuals, 24, length(adf_logwine@test$lm$coefficients))
```
L’absence d’autocorrélation des résidus est rejetée, le test ADF avec aucun
retard n’est donc pas valide. On ajoute donc des retards jusqu’à ce que les résidus ne soient plus autocorrélés.

```{r logwine adf test : cf. TD5}
adfTest_valid <- function(series,kmax,type){ 
# tests ADF jusqu’à des résidus non autocorrélés
k <- 0
noautocorr <- 0
while (noautocorr==0){
cat(paste0("ADF with ",k, " lags: residuals OK? "))
adf <- adfTest(series,lags=k,type=type)
pvals <- Qtests(adf@test$lm$residuals,24,fitdf=length(adf@test$lm$coefficients))[,2]
if (sum(pvals<0.05,na.rm=T) == 0) {
noautocorr <- 1; cat("OK \n")}
else cat("nope \n")
k <- k + 1
}
return(adf)
}
adf <- adfTest_valid(logwine, 24, "ct")
```

```{r show adf}
adf
```
wine = 14 lags
pharm = 11 lags
alim = 8 lags
elec = 21 lags
biere = 9 lags
petrole = 12 lags

```{r dlogwine adf test}
dlogwine.source <- diff(logwine.source, 1)
dlogwine <- diff(logwine, 1)
plot(dlogwine.source, type="l", lwd=1, col="blue", main="dlogwine.source", xlab="dates", ylab="values")
summary(lm(dlogwine ~ dates[2:(length(logwine.source)-6)]))
# il n'y a pas de tendance ni de constante
adf_dlogwine <- adfTest(dlogwine, lag=0, type="nc")
Qtests(adf_dlogwine@test$lm$residuals, 24, length(adf_dlogwine@test$lm$coefficients))
```

```{r dlogwine adf test}
adf <- adfTest_valid(dlogwine,24,"nc")
adf
```
pharm : 10 lags
alim : 6 lags
elec : 12 lags
wine = 15 lags
biere = 8 lags
petrole = 10 lags
spirit = 7 lags

``` {r acf and pacf dlogwine}
acf(dlogwine); pacf(dlogwine)
```

qpharm = 11
ppharm = 12

qspirit = 12
pspirit = 12

qpetrole = 13
ppetrole = 11

qwine = 14 (4)
pwine = 14 (3)

qelec = 24 (7)
pelec = 24 (7)

qalim = 24 (2 / 7)
palim = 7

qbiere = 2
pbiere = 8

``` {r pmax and qmax}
pmax=7; qmax=2
```

``` {r AIC and BIC}
# on définit deux matrices vides à remplir avec les valeurs des AICs et BICs
mat <- matrix(NA, nrow=pmax+1, ncol=qmax+1)
rownames(mat) <- paste0("p=",0:pmax)
colnames(mat) <- paste0("q=",0:qmax)
AICs <- mat
BICs <- mat
# on collecte dans pqs toutes les combinaisons possibles de p et q
pqs <- expand.grid(0:pmax,0:qmax)
# on boucle sur ces combinaisons
for (row in 1:dim(pqs)[1]){
p <- pqs[row,1]
q <- pqs[row,2]
# on assigne les scores AICs et BICs
estim <- try(arima(dlogwine,c(p,0,q),include.mean = F))
AICs[p+1,q+1] <- if (class(estim)=="try-error") NA else estim$aic
BICs[p+1,q+1] <- if (class(estim)=="try-error") NA else BIC(estim)
}

AICs 
AICs==min(AICs) 
BICs
BICs==min(BICs)
```
``` {r best models wine}
# on conserve les modèles ARIMA qui minimisent l'AIC et BIC
arima513 <- arima(logwine,c(5,1,3),include.mean=F)
tarima513 <- arima513$coef / sqrt(diag(arima513$var.coef))
pvarima513 <- (1-pnorm(abs(tarima513)))*2
pvarima513["ar5"]
pvarima513["ma3"]
Qtests(arima513$residuals,24,fitdf=5)

arima111 <- arima(logwine,c(1,1,1),include.mean=F)
tarima111 <- arima111$coef / sqrt(diag(arima111$var.coef))
pvarima111 <- (1-pnorm(abs(tarima111)))*2
pvarima111["ar1"]
pvarima111["ma1"]
Qtests(arima111$residuals,24,fitdf=1)

arima313 <- arima(logwine,c(3,1,3),include.mean=F)
tarima313 <- arima313$coef / sqrt(diag(arima313$var.coef))
pvarima313 <- (1-pnorm(abs(tarima313)))*2
pvarima313["ar3"]
pvarima313["ma3"]
Qtests(arima313$residuals,24,fitdf=3)
arima313
```


``` {r which models ?}
# fonction de test des significativites individuelles des coefficients
signif <- function(estim){
  coef <- estim$coef
  se <- sqrt(diag(estim$var.coef))
  t <- coef/se
  pval <- (1-pnorm(abs(t)))*2
  return(rbind(coef, se, pval))
}

#fonction pour estimer un ARIMA et en verifier l'ajustement et la validite
modelchoice <- function(p, q, data=dlogwine, k=24){
  estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
  if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
  arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
  masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
  resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
  checks <- c(arsignif,masignif,resnocorr)
  ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
  return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}


#fonction pour estimer et verifier tous les ARMA(p,q) avec p<=pmax et q<=max
armamodelchoice <- function(pmax,qmax){
  pqs <- expand.grid(0:pmax,0:qmax) ; t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
    p <- pqs[row,1]; q <- pqs[row,2]
    cat(paste0("Computing ARMA(",p,",",q,") \n"))
    modelchoice(p,q)
  }))}

armamodels <- armamodelchoice(pmax,qmax)

```

``` {r select models}
selec <- armamodels[armamodels[,"ok"]==1&!is.na(armamodels[,"ok"]),] # renvoie les modeles bien ajustes et valides
selec
```











``` {r dlogwine}
# dlogwine est la série logwine en différence première
dlogwine.source <- diff(logwine.source, 1)
dlogwine <- diff(logwine, 1)
plot.ts(dlogwine, type="l", lwd=1, col="red", main="dlogwine", xlab="dates", ylab="values")
```

On cherche à déterminer si la série est stationnaire ou non. Pour cela, on souhaite effectuer un test de racine unitaire ADF dont l'hypothèse H1 est la stationnarité de la série. On effectue le test ADF dans le cas avec constante et tendance.

```{r dlogwine adf test}
# cas avec constante et tendance
adfTest(dlogwine, lag=0, type="ct")
```

```{r dlogwine pp test}
# cas avec constante et tendance
pp.test(dlogwine)
```